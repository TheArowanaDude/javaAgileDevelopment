HW3 Due 11:59PM October 11

According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far. Also, if you like, give from examples outside of this class, but limit to your personal experiences.

According to this aritle the 4 rules of simple design are: Passes tests, reveals intention, no duplication, fewest elements.

Test Driven Development exists to give some assurance that the software is always working as intended, as well as encourage modularity in the code. On our past 2 assignments, we found that TDD would give us an (almost) instantaneous feedback loop that told us whether our code was working as intended whenever we included new code to the program. We also found that generally, TDD would force us to create functions with very specific tasks, as the nature of TDD makes you test for a very specific function output. For an example, for our second assignment, we learned to first focus on taking a timestamp and convert it to a different timezone, later on, we found ourselves combining various specific functions that act as modular components to create a more powerful function.    

The second principle, "revealing intent", is pretty straightforward, other programmers should be able to understand the code, and from our assignments, we learned that we should be using very clear, descriptive names to variables, functions, and testcases even if they seem unnecessarily long; one of our test case names was "JSONStringParseGivenLatLon". For the programs that we've written in class thus far, they are moderately complex, and yet, there is no in-line documentation (so far) because the names we've given to these variables, function, etc provide a sufficient explanation as to what the code is doing. 

The third principle, "no duplication", has 2 names for it in software design and that is "Don't Repeat Yourself" (DRY) and "Single Point of Truth" (SPOT). Though these names seem very different, they represent the very same idea and that is to not have repeating code. The core idea of this principle is that there is a single piece of code that represents an aspect of the system. When you have repeating code that does the same task, it's human nature for that piece of code to subtly change each time it is implemented, thus introducing more points of fault within the system. This principle also has a close relationship with TDD, as there's modularity being encouraged by both of these principles. So far in our assignments, we never really had any repeating code due to our strict adherence with TDD; however in a personal project, there were different data formats as inputs to the system. There was duplicated code for these different formats even though these duplicates were producing the same output. Whenever changes were made to the program, it would send a large ripple effect throughout the system that would cause many issues, and required much time to deal with. If this "no duplication" principle was strictly adhered to, small changes to the code would only have one point of focus to worry about rather than multiple areas within the system. 

The last rule, "fewest elements", is built upon the previous three rules. If there is any variable, function, object, etc that doesn't serve a purpose for any of the aforementioned rules, then it should be removed. Ultimately, the more condense, modular, and cleaner code is, the easier it will be to extend, debug, and enhance. We've found this to be true while working on our assignments. TDD helped us achieve this rule. When running the test cases, we wanted to make sure that the collective test cases were executing every single line of code. We monitored our code coverage to watch out for dead code and to refrain from writing code that didn't serve a purpose towards the test cases.

Total[10]: 10